å·²ç»ä¸ºä½ ä¼˜åŒ–äº†ä»£ç ã€‚é’ˆå¯¹ä½ çš„éœ€æ±‚ï¼Œæˆ‘åšäº†ä»¥ä¸‹æ”¹è¿›ï¼š

1. **è‰²å½©åŒºåˆ†**ï¼šè°ƒæ•´äº†é›ªåœ°çš„æè´¨å±æ€§ä¸åœºæ™¯é›¾æ°”ï¼ˆFogï¼‰çš„é¢œè‰²ã€‚é›ªåœ°ç°åœ¨å¸¦æœ‰æ›´æ˜æ˜¾çš„**å†·è“è‰²ç¯å¢ƒåå°„**ï¼Œä¸çº¯é»‘/æ·±è“çš„å¤œç©ºèƒŒæ™¯åœ¨è§†è§‰ä¸Šäº§ç”Ÿäº†æ›´æ¸…æ™°çš„å±‚çº§æ„Ÿã€‚
2. **æ›´ç»†è…»çš„é›ªèŠ±**ï¼šå°†é›ªèŠ±ç²’å­çš„ `size` ç¼©å°ï¼Œå¹¶å¢åŠ äº†ç²’å­æ•°é‡ï¼Œä½¿å…¶çœ‹èµ·æ¥æ›´åƒç»†å¯†çš„ç²‰é›ªã€‚
3. **æµæ˜Ÿç³»ç»Ÿ**ï¼šæ–°å¢äº†ä¸€ä¸ªæµæ˜Ÿç”Ÿæˆç±»ï¼Œæµæ˜Ÿä¼šä»¥éšæœºçš„æ—¶é—´é—´éš”ã€éšæœºçš„è§’åº¦åˆ’è¿‡å¤©ç©ºï¼Œå¸¦æœ‰æ·¡å‡ºçš„å°¾è¿¹æ•ˆæœã€‚

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å†¬å¤œé›ªæ™¯ - äº¤äº’å¼ä½“éªŒ</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500&family=Crimson+Pro:wght@300;400&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #05081a; 
            font-family: 'Noto Sans SC', sans-serif;
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        .sky-bg {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 100%, #1a2a47 0%, #05081a 100%);
            z-index: 0;
        }

        .stars { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .star {
            position: absolute;
            width: 1.5px; height: 1.5px;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s ease-in-out infinite;
        }
        @keyframes twinkle { 0%, 100% { opacity: 0.2; } 50% { opacity: 0.8; } }

        #video-input {
            position: absolute; bottom: 30px; right: 30px;
            width: 160px; height: 120px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            transform: scaleX(-1);
            z-index: 10;
            opacity: 0.7;
        }

        #ui-overlay { position: absolute; top: 40px; left: 40px; z-index: 20; pointer-events: none; }
        .ui-card {
            background: rgba(5, 8, 26, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 24px;
            color: #e8f0ff;
            max-width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .status-tag {
            display: inline-flex; align-items: center; gap: 8px;
            padding: 6px 14px; background: rgba(255,255,255,0.05);
            border-radius: 20px; margin: 12px 0; font-size: 13px;
        }
        .status-indicator { width: 6px; height: 6px; border-radius: 50%; background: #6eb9ff; box-shadow: 0 0 8px #6eb9ff; }
        
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #05081a; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; color: white;
        }
    </style>
</head>
<body>

<div class="sky-bg">
    <div class="stars" id="stars-container"></div>
</div>

<div id="loading">
    <div style="margin-bottom: 20px; letter-spacing: 2px; font-weight: 300;">æ­£åœ¨ç¼–ç»‡å†¬å¤œ...</div>
</div>

<div id="ui-overlay">
    <div class="ui-card">
        <h2 style="font-family: 'Crimson Pro', serif; font-size: 26px; font-weight: 300;">â„ å¯‚é™é›ªå¤œ</h2>
        <div id="gesture-status" class="status-tag">
            <div class="status-indicator"></div>
            <span>ç­‰å¾…è¯†åˆ«</span>
        </div>
        <div style="font-size: 13px; opacity: 0.6; line-height: 1.8; font-weight: 300;">
            âœ‹ å¼ å¼€æ‰‹æŒ Â· å‘¼å”¤è½é›ª<br>
            âœŠ æ¡ç´§æ‹³å¤´ Â· å‡å›ºç¬é—´<br>
            ğŸ–±ï¸ ç§»åŠ¨é¼ æ ‡ Â· ç¯è§†æ˜Ÿç©º
        </div>
    </div>
</div>

<video id="video-input" autoplay playsinline></video>
<div id="canvas-container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
let scene, camera, renderer, snowflakes, meteors = [];
let mouseX = 0, mouseY = 0, targetX = 0, targetY = 0;
let isSnowing = false;
const GROUND_LEVEL = -5;
const SNOWFLAKE_COUNT = 8000; // å¢åŠ æ•°é‡
let snowVelocities = [];

function init() {
    scene = new THREE.Scene();
    // è°ƒæ•´é›¾æ°”é¢œè‰²ï¼Œä¸èƒŒæ™¯å½¢æˆå¾®å¦™è¿‡æ¸¡
    scene.fog = new THREE.FogExp2(0x0a1025, 0.035);

    camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 18);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0x203060, 1.2);
    scene.add(ambientLight);
    
    // å¢åŠ ä¸€ä¸ªä¾§å‘çš„å†·è“è‰²è¡¥å…‰ï¼Œå¢å¼ºé›ªåœ°è´¨æ„Ÿ
    const sideLight = new THREE.PointLight(0x6eb9ff, 0.5);
    sideLight.position.set(-20, 10, 10);
    scene.add(sideLight);

    const moonLight = new THREE.DirectionalLight(0xffffff, 0.8);
    moonLight.position.set(10, 20, 10);
    scene.add(moonLight);

    createStars();
    createRollingGround();
    createCatTracks();
    createSnowflakes();
    
    window.addEventListener('mousemove', (e) => {
        mouseX = (e.clientX - window.innerWidth / 2) / (window.innerWidth / 2);
        mouseY = (e.clientY - window.innerHeight / 2) / (window.innerHeight / 2);
    });
    
    initMediaPipe();
    animate();
}

function createRollingGround() {
    const geometry = new THREE.PlaneGeometry(150, 150, 80, 80);
    const pos = geometry.attributes.position;
    for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        // å¾®è°ƒèµ·ä¼é¢‘ç‡
        const z = Math.sin(x * 0.1) * 2.0 + Math.cos(y * 0.12) * 1.5;
        pos.setZ(i, z);
    }
    geometry.computeVertexNormals();

    const material = new THREE.MeshStandardMaterial({ 
        color: 0xd0e0ff, // æµ…è“è‰²åº•ï¼Œå¢åŠ é›ªåœ°å†·æ„Ÿ
        roughness: 0.8,
        metalness: 0.1,
        emissive: 0x050a15, // æ·¡æ·¡çš„è‡ªå‘å…‰åŒºåˆ†é»‘æš—éƒ¨
    });

    const ground = new THREE.Mesh(geometry, material);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = GROUND_LEVEL;
    scene.add(ground);
}

function createCatTracks() {
    const trackGroup = new THREE.Group();
    const trackMaterial = new THREE.MeshBasicMaterial({ color: 0x0a1a35, transparent: true, opacity: 0.25 });
    const trackGeom = new THREE.CircleGeometry(0.1, 8);
    const paths = [
        { startX: -3, startZ: 12, count: 20, step: -0.7 },
        { startX: 10, startZ: 8, count: 12, step: -0.6 }
    ];
    paths.forEach(path => {
        for (let i = 0; i < path.count; i++) {
            const track = new THREE.Mesh(trackGeom, trackMaterial);
            track.rotation.x = -Math.PI / 2;
            const side = i % 2 === 0 ? 0.2 : -0.2;
            track.position.set(path.startX + side, GROUND_LEVEL + 0.25, path.startZ + (i * path.step));
            track.scale.set(1, 1.2, 1);
            trackGroup.add(track);
        }
    });
    scene.add(trackGroup);
}

function createSnowflakes() {
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    for (let i = 0; i < SNOWFLAKE_COUNT; i++) {
        positions.push((Math.random()-0.5)*120, Math.random()*60, (Math.random()-0.5)*120);
        snowVelocities.push({ y: -0.015 - Math.random()*0.02, x: (Math.random()-0.5)*0.008 });
    }
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    
    const material = new THREE.PointsMaterial({
        size: 0.08, // ç¼©å°å°ºå¯¸
        color: 0xffffff,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
    });
    snowflakes = new THREE.Points(geometry, material);
    scene.add(snowflakes);
}

// æµæ˜Ÿé€»è¾‘
function spawnMeteor() {
    if (Math.random() > 0.993) { // éšæœºè§¦å‘
        const geometry = new THREE.BufferGeometry();
        const startX = (Math.random() - 0.5) * 100;
        const startY = 20 + Math.random() * 10;
        const startZ = -20 - Math.random() * 20;
        
        const points = [];
        for(let i=0; i<10; i++) points.push(startX, startY, startZ);
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
        
        const material = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1 });
        const line = new THREE.Line(geometry, material);
        
        const velocity = { x: (Math.random() - 0.5) * 2, y: -0.8 - Math.random(), z: 0.5 };
        meteors.push({ mesh: line, vel: velocity, life: 1.0 });
        scene.add(line);
    }
}

function updateMeteors() {
    for (let i = meteors.length - 1; i >= 0; i--) {
        const m = meteors[i];
        m.mesh.position.x += m.vel.x;
        m.mesh.position.y += m.vel.y;
        m.mesh.position.z += m.vel.z;
        m.life -= 0.02;
        m.mesh.material.opacity = m.life;
        
        if (m.life <= 0) {
            scene.remove(m.mesh);
            meteors.splice(i, 1);
        }
    }
}

function animate() {
    requestAnimationFrame(animate);

    targetX += (mouseX - targetX) * 0.04;
    targetY += (mouseY - targetY) * 0.04;
    camera.position.x = targetX * 5;
    camera.position.y = 2 + (targetY * -3);
    camera.lookAt(0, 0, 0);

    if (isSnowing && snowflakes) {
        const pos = snowflakes.geometry.attributes.position.array;
        for (let i = 0; i < SNOWFLAKE_COUNT; i++) {
            pos[i*3 + 1] += snowVelocities[i].y;
            pos[i*3] += snowVelocities[i].x;
            if (pos[i*3 + 1] < GROUND_LEVEL) pos[i*3 + 1] = 50;
        }
        snowflakes.geometry.attributes.position.needsUpdate = true;
    }

    spawnMeteor();
    updateMeteors();
    renderer.render(scene, camera);
}

function createStars() {
    const container = document.getElementById('stars-container');
    for (let i = 0; i < 200; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 70 + '%';
        star.style.animationDelay = Math.random() * 5 + 's';
        container.appendChild(star);
    }
}

function setSnowingState(state) {
    isSnowing = state;
    const indicator = document.querySelector('.status-indicator');
    const text = document.querySelector('#gesture-status span');
    indicator.style.background = state ? "#6eb9ff" : "#ff9d76";
    indicator.style.boxShadow = state ? "0 0 8px #6eb9ff" : "0 0 8px #ff9d76";
    text.textContent = state ? "é›ªèŠ±é£˜è½" : "å·²æš‚åœ";
}

function initMediaPipe() {
    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
    hands.onResults(results => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            const isOpen = Math.abs(lm[8].y - lm[0].y) > 0.25;
            setSnowingState(isOpen);
        }
    });

    const cameraInput = new Camera(document.getElementById('video-input'), {
        onFrame: async () => { await hands.send({ image: document.getElementById('video-input') }); },
        width: 640, height: 480
    });
    cameraInput.start().then(() => { document.getElementById('loading').style.display = 'none'; });
}

init();
</script>
</body>
</html>

```